package dev.strip;

import js.base.BaseObject;
import js.file.Files;
import js.json.JSList;
import js.json.JSMap;

import java.io.File;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static js.base.Tools.*;

public class FilterState extends BaseObject {

//  private FilterState(FilterState source) {
//    mDirectoryAbs = source.mDirectoryAbs;
//    mDeleteFilesAbs.addAll(source.mDeleteFilesAbs);
//  }

  public File directory() {
    return mDirectoryAbs;
  }

  public FilterState(File containerDir, Collection<File> deleteFilenamesAbs) {
    mDirectoryAbs = Files.assertAbsolute(containerDir);
    for (var s : deleteFilenamesAbs)
      addDeleteFileAbs(s);
  }

  /**
   * Construct a new FilterState by descending into a subdirectory of the current state's directory
   */
  public FilterState descendInto(File absSubdir) {
    todo("can we have the directory in this FilterState as well?");
    todo("this is clunky and doesn't work");
    var rel = Files.relativeToContainingDirectory(absSubdir, this.directory());
    log("descendInto:", rel);
    var fs = new FilterState(absSubdir, this.deleteFilesAbs());
//    var fs = this.dup();
//    fs.mDirectoryAbs = absSubdir;
    log("...returning:", INDENT, fs);
    return fs;
  }

  public Set<File> deleteFilesAbs() {
    return mDeleteFilesAbs;
  }

  public void addDeleteFileAbs(File fileAbs) {
    todo("get rid of file validator dfa");
    Files.assertAbsolute(fileAbs);
    mDeleteFilesAbs.add(fileAbs);
  }
//
//  private String validateFilename(String filename) {
//    checkArgument(isValidFilename(filename), "filename is illegal:", filename);
//    return filename;
//  }

  private final File mDirectoryAbs;

  // This map should be considered immutable.  If changes are made, construct a new copy
  private final  Set<File> mDeleteFilesAbs = hashSet();

//  private static DFA sValidatorDFA = DFA.parse(Files.readString(FilterState.class, "filter_expr.dfa"));

  // Token Ids generated by 'dev dfa' tool (DO NOT EDIT BELOW)
  public static final int T_REL_PATH = 0;
  // End of token Ids generated by 'dev dfa' tool (DO NOT EDIT ABOVE)

//  public static boolean isValidFilename(String filename) {
//    var s = new Lexer(sValidatorDFA).withText(filename).withNoSkip();
//    try {
//      s.read(T_REL_PATH);
//      checkState(!s.hasNext());
//    } catch (Throwable t) {
//      return false;
//    }
//    return true;
//  }

  @Override
  public JSMap toJson() {
    var m = map();
    List<String> lst = arrayList();
    for (var x : mDeleteFilesAbs)
      lst.add(x.toString());
    lst.sort(null);
    m.put("delete_files", JSList.with(lst));
    return m;
  }
}
