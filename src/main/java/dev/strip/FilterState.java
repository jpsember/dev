package dev.strip;

import js.base.BaseObject;
import js.file.Files;
import js.json.JSList;
import js.json.JSMap;
import js.parsing.DFA;
import js.parsing.Lexer;

import java.io.File;
import java.util.Collection;
import java.util.List;
import java.util.Set;

import static js.base.Tools.*;

public class FilterState extends BaseObject {

  private FilterState() {
  }

  public FilterState(File containerDir, Collection<String> deleteFilenamesRel) {
    for (var s : deleteFilenamesRel)
      addDeleteFileAbs(Files.join(containerDir, s));
  }

  /**
   * Construct a new FilterState by descending into a subdirectory of the current state's directory
   */
  public FilterState descendInto(File relativeSubdir) {
    todo("can we have the directory in this FilterState as well?");
    todo("this is clunky and doesn't work");
    log("descendInto:", relativeSubdir);
    Files.assertRelative(relativeSubdir);
    var fs = this.dup();
    log("...returning:", INDENT, fs);
    return fs;
  }

  public Set<File> deleteFilesAbs() {
    return mDeleteFilesAbs;
  }

  public FilterState dup() {
    var s = new FilterState();
    s.mDeleteFilesAbs.addAll(mDeleteFilesAbs);
    return s;
  }

  public void addDeleteFileAbs(File fileAbs) {
    todo("get rid of file validator dfa");
    Files.assertAbsolute(fileAbs);
    mDeleteFilesAbs.add(fileAbs);
  }
//
//  private String validateFilename(String filename) {
//    checkArgument(isValidFilename(filename), "filename is illegal:", filename);
//    return filename;
//  }

  // This map should be considered immutable.  If changes are made, construct a new copy
  private final Set<File> mDeleteFilesAbs = hashSet();

//  private static DFA sValidatorDFA = DFA.parse(Files.readString(FilterState.class, "filter_expr.dfa"));

  // Token Ids generated by 'dev dfa' tool (DO NOT EDIT BELOW)
  public static final int T_REL_PATH = 0;
  // End of token Ids generated by 'dev dfa' tool (DO NOT EDIT ABOVE)

//  public static boolean isValidFilename(String filename) {
//    var s = new Lexer(sValidatorDFA).withText(filename).withNoSkip();
//    try {
//      s.read(T_REL_PATH);
//      checkState(!s.hasNext());
//    } catch (Throwable t) {
//      return false;
//    }
//    return true;
//  }

  @Override
  public JSMap toJson() {
    var m = map();
    List<String> lst = arrayList();
    for (var x : mDeleteFilesAbs)
      lst.add(x.toString());
    lst.sort(null);
    m.put("delete_files", JSList.with(lst));
    return m;
  }
}
