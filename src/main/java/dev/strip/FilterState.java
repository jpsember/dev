package dev.strip;

import js.base.BaseObject;
import js.file.Files;
import js.json.JSList;
import js.json.JSMap;
import js.parsing.DFA;
import js.parsing.Lexer;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import static js.base.Tools.*;

public class FilterState extends BaseObject {

  private FilterState() {
  }

  public FilterState(Collection<String> deleteFilenames) {
    for (var s : deleteFilenames)
      addDeleteFile(s);
  }

  public FilterState descendInto(String subdirName) {
    log("descendInto:", subdirName);
    var fs = new FilterState();
    log("...subdir name", subdirName);
    for (var x : mDeleteFilenames) {
      var i = x.indexOf('/');
      if (i < 0) i = x.length();
      var dir = x.substring(0, i);
      log("...del filename:", x, "i:", i, "dir:", dir);
      if (!dir.equals(subdirName)) continue;
      checkState(i < x.length());
      var survivor = x.substring(i + 1);
      log("...adding survivor:", survivor);
      fs.mDeleteFilenames.add(survivor);
    }
    log("...returning:", INDENT, fs);
    return fs;
  }


  public Set<String> deleteFilenames() {
    return mDeleteFilenames;
  }

  public FilterState dup() {
    var s = new FilterState();
    s.mDeleteFilenames.addAll(mDeleteFilenames);
    return s;
  }

  public void addDeleteFile(String filename) {
    filename = validateFilename(filename);
    mDeleteFilenames.add(filename);
  }

  private String validateFilename(String filename) {
    checkArgument(isValidFilename(filename), "filename is illegal:", filename);
    return filename;
  }

  // This map should be considered immutable.  If changes are made, construct a new copy
  private final Set<String> mDeleteFilenames = hashSet();

  private static DFA sValidatorDFA = DFA.parse(Files.readString(FilterState.class, "filter_expr.dfa"));

  // Token Ids generated by 'dev dfa' tool (DO NOT EDIT BELOW)
  private static final int T_REL_PATH = 0;
  // End of token Ids generated by 'dev dfa' tool (DO NOT EDIT ABOVE)

  public static boolean isValidFilename(String filename) {
    var s = new Lexer(sValidatorDFA).withText(filename).withNoSkip();
    try {
      s.read(T_REL_PATH);
      checkState(!s.hasNext());
    } catch (Throwable t) {
      return false;
    }
    return true;
  }

  @Override
  public JSMap toJson() {
    var m = map();
    List<String> lst = arrayList();
    lst.addAll(mDeleteFilenames);
    lst.sort(null);
    m.put("filenames", JSList.with(lst));
    return m;
  }
}