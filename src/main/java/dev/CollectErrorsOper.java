package dev;

import static js.base.Tools.*;

import dev.gen.CollectErrorsConfig;
import dev.gen.ErrInfo;
import js.app.AppOper;
import js.app.HelpFormatter;
import js.base.BasePrinter;
import js.file.DirWalk;
import js.file.Files;
import js.parsing.DFA;
import js.parsing.Lexeme;
import js.parsing.Lexer;

import java.util.List;
import java.util.Map;

public class CollectErrorsOper extends AppOper {

  @Override
  public String userCommand() {
    return "collect-errs";
  }

  @Override
  public String shortHelp() {
    return "collect error codes into a table";
  }

  @Override
  protected void longHelp(BasePrinter b) {
    var hf = new HelpFormatter();
    hf.addItem("***", "** no 'long' help available yet");
    b.pr(hf);
    b.br();
  }

  @Override
  public CollectErrorsConfig defaultArgs() {
    return CollectErrorsConfig.DEFAULT_INSTANCE;
  }

  @Override
  public CollectErrorsConfig config() {
    if (mConfig == null) {
      mConfig = (CollectErrorsConfig) super.config();
    }
    return mConfig;
  }

  @Override
  public void perform() {
    var inputDirectory = Files.assertDirectoryExists(config().input(), "input directory");
    var dfa = DFA.parse(Files.readString(getClass(), "collect_errors.dfa"));
    var extensions = arrayList("java", "rs", "py");
    var dirWalk = new DirWalk(inputDirectory).withRecurse(true).withExtensions(extensions);

    for (var sourceFile : dirWalk.files()) {

      var txt = Files.readString(sourceFile);
      var scanner = new Lexer(dfa);
      scanner.withSkipId(T_SPACES);
      scanner.withAcceptUnknownTokens();
      scanner.withText(txt);
      scanner.setVerbose();

      List<String> comments = arrayList();


      // If a COMMENT is found, add to the comment buffer
      // If a CR is found, clear the comments
      // If something other than ERRCODE_xxxx, read and continue

      while (scanner.hasNext()) {

        Lexeme errCodeToken = null;
        String idStr = null;
        if (scanner.readIf(T_CR)) {
          comments.clear();
        } else if (scanner.readIf(T_COMMENT)) {
          comments.add(scanner.token().text());
        } else if (!scanner.readIf(T_ERRCODE)) {
          scanner.read();
        } else {
          errCodeToken = scanner.token(0);
          idStr = findOptErrorNumber(scanner);
          if (idStr == null)
            continue;

          // Construct description of error from buffered comments
          var expr = new StringBuilder();
          for (var c : comments) {
            var c2 = chompPrefix(c, "# ");
            if (c2 == c)
              c2 = chompPrefix(c, "// ");
            expr.append(c2);
          }
          var desc = expr.toString();
          if (desc.isEmpty()) {
            errCodeToken.failWith("no comment found");
          }

          var b = ErrInfo.newBuilder();
          b.id(Integer.parseInt(idStr));
          b.name(chompPrefix(errCodeToken.text(), "ERROR_"));
          b.description(desc);

          if (mInfoMap.containsKey(b.id())) {
            setError("duplicate error number:", INDENT, b, CR, mInfoMap.get(b.id()));
          }
          mInfoMap.put(b.id(), b);
          log("Storing:", scanner.token(0), INDENT, b);

          comments.clear();

        }
      }
    }

    String result;
    {
      var sb = new StringBuilder();
      ErrInfo prevEnt = null;
      for (var errInfo : mInfoMap.values()) {
        if (prevEnt != null && errInfo.id() / 1000 != prevEnt.id() / 1000)
          sb.append("\n");
        prevEnt = errInfo;
        sb.append(String.format("%5d %s", errInfo.id(), chompPrefix(errInfo.name(), "ERRCODE_")));
        sb.append('\n');
        for (var line : split(errInfo.description(), '\n')) {
          sb.append(spaces(6));
          sb.append(line);
          sb.append('\n');
        }
      }
      result = sb.toString();
    }

    var outputFile = config().output();

    if (Files.empty(outputFile)) {
      System.out.println(result);
    } else {
      log("\n", insertLeftMarginChars(result.toString()));
      files().writeIfChanged(outputFile, result);
    }
  }

  private String findOptErrorNumber(Lexer scanner) {
    // Read until newline or we find the integer error value
    while (true) {
      if (!scanner.hasNext()) return null;
      if (scanner.peekIf(T_CR)) return null;
      if (scanner.readIf(T_EQUALS, T_INT)) break;
      if (scanner.peekIf(T_EQUALS)) return null;
      scanner.read();
    }

    var idToken = scanner.token(1);
    return idToken.text();
  }

  private static String insertLeftMarginChars(String text) {
    var sb = new StringBuilder();
    for (var ls : split(text, '\n')) {
      sb.append("|  ");
      sb.append(ls);
      sb.append('\n');
    }
    return sb.toString();
  }

  private CollectErrorsConfig mConfig;
  private Map<Integer, ErrInfo> mInfoMap = treeMap();

  // Token Ids generated by 'dev dfa' tool (DO NOT EDIT BELOW)
  private static final int T_SPACES = 0;
  private static final int T_CR = 1;
  private static final int T_COMMENT = 2;
  private static final int T_INT = 3;
  private static final int T_EQUALS = 4;
  private static final int T_ERRCODE = 5;
  // End of token Ids generated by 'dev dfa' tool (DO NOT EDIT ABOVE)

}
