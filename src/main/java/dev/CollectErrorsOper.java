package dev;

import static js.base.Tools.*;

import dev.gen.CollectErrorsConfig;
import dev.gen.ErrInfo;
import js.app.AppOper;
import js.app.HelpFormatter;
import js.base.BasePrinter;
import js.file.DirWalk;
import js.file.Files;
import js.parsing.DFA;
import js.parsing.Lexeme;
import js.parsing.Lexer;

import java.util.List;
import java.util.Map;

public class CollectErrorsOper extends AppOper {

  @Override
  public String userCommand() {
    return "collect-errs";
  }


  @Override
  public String shortHelp() {
    return "no help is available for operation";
  }

  @Override
  protected void longHelp(BasePrinter b) {
    var hf = new HelpFormatter();
    hf.addItem("***", "** no 'long' help available yet");
    b.pr(hf);
    b.br();
  }

  @Override
  public CollectErrorsConfig defaultArgs() {
    return CollectErrorsConfig.DEFAULT_INSTANCE;
  }

  @Override
  public CollectErrorsConfig config() {
    if (mConfig == null) {
      mConfig = (CollectErrorsConfig) super.config();
    }
    return mConfig;
  }

  @Override
  public void perform() {
    var f = Files.assertDirectoryExists(config().input(), "input directory");

    var dfa = DFA.parse(Files.readString(getClass(), "collect_errors.dfa"));
    var ext = arrayList("java", "rs", "py");
    var dw = new DirWalk(f).withRecurse(true).withExtensions(ext);

    for (var w : dw.files()) {
      pr(VERT_SP,"Reading file:",w,CR,DASHES);

      var txt = Files.readString(w);
      var s = new Lexer(dfa);
      s.withSkipId(T_SPACES);
      s.withAcceptUnknownTokens();
      s.withText(txt);
      s.setVerbose();

      List<String> comments = arrayList();

      outer:
      while (s.hasNext()) {

        log("token:", INDENT, s.peek());
        if (s.readIf(T_COMMENT)) {
          comments.add(s.token().text());
          continue;
        }

        if (s.readIf(T_CR)) {
          comments.clear();
          continue;
        }

        if (!s.readIf(T_ERRCODE)) {
          s.read();
          continue;
        }
        var errCodeToken = s.token(0);

        pr(VERT_SP, "found errcode token:", errCodeToken);

        // Read until newline or we find the integer error value

        while (s.hasNext() && !s.peekIf(T_CR)) {
          if (!s.readIf(T_INT)) {
            s.read();
            continue;
          }
          var idToken = s.token(0);
          pr(VERT_SP, "found id token:", idToken);

          // Construct description of error from buffered comments
          var expr = new StringBuilder();
          for (var c : comments) {
            var c2 = chompPrefix(c, "# ");
            if (c2 == c)
              c2 = chompPrefix(c, "// ");
            expr.append(c2);
          }
          var desc = expr.toString();
          if (desc.isEmpty()) {
            errCodeToken.failWith("no comment found");
          }

          var b = ErrInfo.newBuilder();
          var idStr = idToken.text();
          b.id(Integer.parseInt(idStr));
          b.name(chompPrefix(errCodeToken.text(), "ERROR_"));
          b.description(desc);

          if (mInfoMap.containsKey(b.id())) {
            setError("duplicate error number:", INDENT, b, CR, mInfoMap.get(b.id()));
          }
          mInfoMap.put(b.id(), b);
          log("Storing:", s.token(0), INDENT, b);
          pr(VERT_SP, "stored:", INDENT, b);

          comments.clear();
          continue outer;
        }
      }
    }

    String result;
    {
      var sb = new StringBuilder();
      ErrInfo prevEnt = null;

      for (var errInfo : mInfoMap.values()) {
        if (prevEnt != null && errInfo.id() / 1000 != prevEnt.id() / 1000)
          sb.append("\n");
        prevEnt = errInfo;

        sb.append(String.format("%5d %s", errInfo.id(), chompPrefix(errInfo.name(), "ERRCODE_")));
        sb.append('\n');

        for (var line : split(errInfo.description(), '\n')) {
          sb.append(spaces(6));
          sb.append(line);
          sb.append('\n');
        }
      }
      result = sb.toString();
    }

    var outputFile = config().output();


    var disp = insertLeftMarginChars(result.toString());
    if (Files.empty(outputFile)) {
      pr(disp);
    } else {
      log(disp);
      files().writeIfChanged(outputFile, result);
    }
  }

  private static String insertLeftMarginChars(String text) {
    var sb = new StringBuilder();
    for (var ls : split(text, '\n')) {
      sb.append("|  ");
      sb.append(ls);
      sb.append('\n');
    }
    return sb.toString();
  }

  private CollectErrorsConfig mConfig;
  private Map<Integer, ErrInfo> mInfoMap = treeMap();

  // Token Ids generated by 'dev dfa' tool (DO NOT EDIT BELOW)
  public int T_SPACES = 0;
  public int T_CR = 1;
  public int T_COMMENT = 2;
  public int T_INT = 3;
  public int T_ERRCODE = 4;
  // End of token Ids generated by 'dev dfa' tool (DO NOT EDIT ABOVE)

}
